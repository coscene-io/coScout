# Master-Slave 架构设计文档

## 1. 整体方案设计

### 1.1 问题背景

#### 1.1.1 核心业务场景：人形机器人多板子控制

随着人形机器人技术的发展，单个机器人系统通常由多个独立的控制板子组成，每个板子负责不同的功能模块：

- **主控板**：核心控制逻辑，运行主操作系统
- **传感器板**：处理各类传感器数据（视觉、力觉、触觉等）
- **执行器板**：控制关节电机、驱动等执行机构
- **通信板**：处理外部通信和网络交互

**关键问题**：
- 每个板子运行独立的操作系统，产生各自的日志和数据文件
- 当前单机模式的采集方案只能采集单个节点的文件，无法覆盖机器人所有板子
- 机器人作为一个整体，需要统一采集所有板子的数据才能完整还原运行状态
- 板子之间通常在同一内网，但可能无法直接访问外网

#### 1.1.2 通用分布式场景

除了人形机器人场景，在通用分布式环境中也存在类似需求：

- **单机模式限制**：每个内网机器需要独立配置云服务连接，无法利用网络优势
- **统一管理需求**：多台内网机器产生的数据需要统一收集和上传
- **网络隔离**：内网机器无法直接访问云端，但可以与同一内网的 master 节点通信

#### 1.1.3 解决方案需求

Master-Slave 架构通过**中心化控制 + 分布式执行**的方式，解决多节点文件采集问题：

- **Master 节点**：通常部署在主控板或具备外网连接的节点上，统一管理所有板子（Slave）的数据采集
- **Slave 节点**：各个功能板子作为 Slave，仅需内网连接，将本地文件信息提供给 Master
- **统一采集**：Master 聚合所有 Slave 的文件信息，统一上传到云端，实现完整的机器人数据采集

### 1.2 核心设计哲学

**"Never break userspace" - 零破坏性**
- 现有单机模式完全兼容，不受任何影响
- 未启用 master-slave 时，系统行为与单机模式完全一致
- 通过配置开关控制，默认关闭，避免误用

**"文件路径设计"**
- 文件路径统一标识：`slave://slaveID/absolutePath`
- Task、Rule、Upload 模块统一增强，而非特殊处理
- 文件管理器抽象层，本地文件和 slave 文件使用相同接口

**实用主义 - 简单可靠**
- HTTP API 通信，无复杂依赖
- 单个 slave 故障不影响整体功能
- 文件按需下载，避免资源浪费

### 1.3 方案概述

Master-Slave 架构采用**中心化控制 + 分布式执行**的模式，完美适配人形机器人多板子控制场景：

#### 1.3.1 在人形机器人场景中的应用

以人形机器人为例：
- **Master 节点**：部署在主控板上（通常具备外网连接能力），作为整个机器人系统的数据采集中心
- **Slave 节点**：各个功能板子（传感器板、执行器板、通信板等）作为 Slave，无需外网连接
- **统一采集**：Master 统一接收云端任务，并发采集所有板子的文件，实现完整的机器人数据采集

#### 1.3.2 核心组件职责

1. **Master 节点**：具备外网连接，负责：
   - 接收云端任务（任务模式）或触发规则（规则模式）
   - 管理所有 slave 节点（注册、心跳、状态维护）
   - 并发请求所有 slave 扫描文件
   - 聚合所有 slave 的文件信息
   - 统一上传到云端（slave 文件按需下载后上传）

2. **Slave 节点**：仅内网连接，负责：
   - 启动时向 master 注册
   - 定期发送心跳保活
   - 响应 master 的文件扫描请求
   - 提供文件下载服务（按需下载）
   - 优雅退出时注销

3. **统一架构**：
   - Task Handler：同时处理本地（Master）和所有 Slave 的文件
   - Rule Handler：同时扫描本地和所有 Slave 的文件
   - Upload Collector：统一上传逻辑，自动识别 slave 文件并处理

## 2. 架构设计

### 2.1 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        Cloud Service                        │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            │ HTTPS/API
                            │
┌───────────────────────────▼─────────────────────────────────┐
│                      Master Node                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Task Handler │  │ Rule Handler │  │  Uploader    │     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘     │
│         │                 │                  │             │
│  ┌──────▼─────────────────▼──────────────────▼───────┐     │
│  │         FileManager (统一文件接口)                 │     │
│  └──────┬───────────────────────────────────────┬─────┘     │
│         │                                       │           │
│  ┌──────▼──────────┐              ┌───────────▼────────┐  │
│  │ Master Server   │              │  Master Client      │  │
│  │ (HTTP API)      │              │  (HTTP Client)      │  │
│  └──────┬──────────┘              └───────────┬────────┘  │
│         │                                      │           │
│  ┌──────▼──────────────────────────────────────▼───────┐  │
│  │         SlaveRegistry (节点注册表)                   │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            │ HTTP (内网)
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼────────┐  ┌───────▼────────┐  ┌───────▼────────┐
│  Slave Node 1  │  │  Slave Node 2  │  │  Slave Node N  │
│  ┌──────────┐  │  │  ┌──────────┐  │  │  ┌──────────┐  │
│  │Slave     │  │  │  │Slave     │  │  │  │Slave     │  │
│  │Server    │  │  │  │Server    │  │  │  │Server    │  │
│  │(HTTP API)│  │  │  │(HTTP API)│  │  │  │(HTTP API)│  │
│  └────┬─────┘  │  │  └────┬─────┘  │  │  └────┬─────┘  │
│       │        │  │       │        │  │       │        │
│  ┌────▼────┐   │  │  ┌────▼────┐  │  │  ┌────▼────┐  │
│  │File     │   │  │  │File     │  │  │  │File     │  │
│  │System   │   │  │  │System   │  │  │  │System   │  │
│  └─────────┘   │  │  └─────────┘  │  │  └─────────┘  │
└────────────────┘  └────────────────┘  └────────────────┘
```

**架构说明（人形机器人场景）**：
- **Master Node**：部署在主控板上，具备外网连接能力，作为整个机器人系统的数据采集中心
- **Slave Node 1-N**：代表各个功能板子（如传感器板、执行器板、通信板等），每个板子运行独立的操作系统和文件系统
- **内网通信**：所有板子通过机器人内部网络（通常为以太网或CAN总线转以太网）连接，Master 和 Slave 之间通过 HTTP API 通信
- **统一采集**：Master 统一接收云端任务，并发采集所有板子的文件，实现完整的机器人运行数据采集

### 2.2 数据流向

#### 任务下发流程（Task 模式）
```
Cloud → Master(主控板) → {主控板本地文件 + 传感器板 + 执行器板 + 通信板 + ...} 
  → 聚合所有板子文件 → 统一上传 → Cloud
```

**说明**：云端任务下发到主控板（Master），Master 并发请求所有功能板子（Slave）扫描文件，聚合后统一上传。

#### 规则触发流程（Rule 模式）
```
主控板规则触发 → Master → {主控板本地文件 + 所有功能板子文件} 
  → 聚合所有板子文件 → 统一上传 → Cloud
```

**说明**：主控板上的规则引擎触发后，Master 同时扫描主控板和所有功能板子的文件，实现完整的机器人数据采集。

#### 文件上传流程
```
Master Upload Queue (主控板上传队列)
  ├─ 主控板本地文件 → 直接上传
  └─ 功能板子文件 → 从板子下载 → 缓存 → 上传 → 清理缓存
```

**说明**：主控板本地文件直接上传，功能板子的文件按需下载到主控板缓存后上传，上传完成后清理缓存。

### 2.3 核心数据结构

#### 文件标识（File Path）
```
本地文件: /absolute/path/to/file
Slave文件: slave://slaveID/absolute/path/to/file
```

**设计要点**：
- 统一路径格式，消除特殊情况
- `slave://` 协议前缀，清晰标识文件来源
- Slave ID 固定16字符，保证唯一性
- 绝对路径，避免路径解析歧义

#### Slave 信息（SlaveInfo）
```
- ID: 唯一标识符（16字符）
- IP: 节点 IP 地址
- Port: 服务端口
- Status: 在线状态（Online/Offline）
- LastSeen: 最后心跳时间
- FilePrefix: 文件前缀（用于组织上传文件）
```

#### 任务请求（TaskRequest）
```
- TaskID: 任务标识
- StartTime: 扫描起始时间
- EndTime: 扫描结束时间
- ScanFolders: 扫描目录列表
- AdditionalFiles: 附加文件列表
```

#### 任务响应（TaskResponse）
```
- TaskID: 任务标识
- Files: 文件列表（包含路径、大小、修改时间等）
- Success: 是否成功
```

## 3. 功能模块设计

### 3.1 Master 模块

#### 3.1.1 Master Server（HTTP 服务端）

**职责**：
- 提供 HTTP API 接收 slave 注册、心跳、注销请求
- 维护 slave 注册表
- 定期清理超时 slave

**核心接口**：
- `POST /api/v1/slave/register` - 接收 slave 注册
- `POST /api/v1/slave/heartbeat` - 接收 slave 心跳
- `POST /api/v1/slave/unregister` - 接收 slave 注销
- `GET /api/v1/slaves` - 查询在线 slave 列表
- `GET /api/v1/health` - 健康检查

**关键设计**：
- **线程安全**：SlaveRegistry 使用读写锁保护
- **自动清理**：后台 goroutine 定期检查超时 slave
- **优雅降级**：slave 注册失败不影响 master 运行

#### 3.1.2 Master Client（HTTP 客户端）

**职责**：
- 向 slave 发送文件扫描请求
- 从 slave 下载文件
- 并发处理多个 slave 请求

**核心方法**：
- `RequestSlaveFiles()` - 请求 slave 扫描文件
- `RequestSlaveFilesByContent()` - 基于内容时间扫描
- `DownloadSlaveFile()` - 下载 slave 文件
- `RequestAllSlaveFiles()` - 并发请求所有 slave

**关键设计**：
- **并发控制**：使用 goroutine 并发请求所有 slave
- **错误隔离**：单个 slave 失败不影响其他 slave
- **超时控制**：请求超时后快速失败，避免阻塞

#### 3.1.3 FileManager（文件管理器）

**职责**：
- 统一文件访问接口
- 自动识别本地文件和 slave 文件
- 为 slave 文件提供透明的读取接口

**核心方法**：
- `GetFileReader()` - 获取文件读取器（本地或 slave）
- `IsSlaveFile()` - 判断是否为 slave 文件
- `ParseSlaveFilePath()` - 解析 slave 文件路径

**关键设计**：
- **统一抽象**：本地文件和 slave 文件使用相同接口
- **按需下载**：slave 文件在需要时才下载
- **流式传输**：大文件支持流式读取，避免内存占用

#### 3.1.4 SlaveRegistry（Slave 注册表）

**职责**：
- 存储所有注册的 slave 信息
- 提供线程安全的查询接口
- 维护 slave 在线状态

**核心方法**：
- `Register()` - 注册/更新 slave
- `Unregister()` - 注销 slave
- `GetOnlineSlaves()` - 获取在线 slave 列表
- `UpdateHeartbeat()` - 更新心跳时间
- `CheckAndCleanup()` - 检查并清理超时 slave

**关键设计**：
- **线程安全**：使用 RWMutex 保护并发访问
- **状态管理**：自动标记超时 slave 为离线
- **快速查询**：O(1) 复杂度的查询操作

### 3.2 Slave 模块

#### 3.2.1 Slave Client（Master 客户端）

**职责**：
- 向 master 注册
- 定期发送心跳
- 处理注册失败重试

**核心流程**：
1. 启动时自动注册
2. 注册成功后启动心跳 goroutine
3. 心跳失败后重试注册
4. 优雅退出时注销

**关键设计**：
- **自动重试**：注册失败后自动重试
- **心跳保活**：定期发送心跳保持连接
- **优雅退出**：进程退出时主动注销

#### 3.2.2 Slave Server（HTTP 服务端）

**职责**：
- 接收 master 的文件扫描请求
- 提供文件下载服务
- 健康检查接口

**核心接口**：
- `POST /api/v1/files/scan` - 文件扫描请求
- `POST /api/v1/files/scan-by-content` - 基于内容时间扫描
- `POST /api/v1/files/download` - 文件下载请求
- `GET /api/v1/health` - 健康检查

**关键设计**：
- **路径安全**：检查文件路径权限，防止路径遍历攻击
- **流式传输**：大文件流式传输，支持 Range 请求
- **错误处理**：文件不存在、权限不足等错误明确返回

### 3.3 集成模块

#### 3.3.1 Task Handler（任务处理器）

**职责增强**：
- 处理云端任务时，同时扫描本地和所有 slave 文件
- 聚合所有文件信息，创建统一上传任务

**工作流程**：
1. 接收云端任务
2. 扫描本地文件
3. 并发请求所有 slave 扫描文件
4. 合并文件列表（去重）
5. 创建上传任务

**关键设计**：
- **零侵入**：master-slave 逻辑与现有代码解耦
- **并发优化**：slave 请求并发执行，提高效率
- **错误容忍**：slave 请求失败不影响本地文件处理

#### 3.3.2 Rule Handler（规则处理器）

**职责增强**：
- Rule 引擎触发时，同时扫描本地和所有 slave 文件
- 统一创建上传任务

**工作流程**：
1. Rule 引擎触发，创建 collectInfo
2. Master 定时扫描 collectInfo
3. 同时扫描本地文件和所有 slave 文件
4. 合并文件信息并创建上传任务

**关键设计**：
- **统一流程**：与 Task 模式使用相同的文件扫描逻辑
- **定时触发**：定期扫描 collectInfo，避免遗漏

#### 3.3.3 Upload Collector（上传收集器）

**职责增强**：
- 识别 slave 文件，自动下载到缓存
- 统一上传逻辑，本地文件和 slave 文件使用相同流程

**工作流程**：
1. 从上传队列获取文件
2. 判断文件类型：
   - 本地文件 → 直接上传
   - Slave 文件 → 下载到缓存 → 上传 → 清理缓存
3. 使用统一的上传接口

**关键设计**：
- **缓存优化**：检查缓存文件大小，避免重复下载
- **自动清理**：上传完成后自动清理缓存
- **错误恢复**：下载失败不影响其他文件上传

## 4. 模块区分

### 4.1 模块分层

```
┌─────────────────────────────────────────┐
│     Application Layer                  │
│  (Task Handler, Rule Handler)         │
└───────────────┬─────────────────────────┘
                │
┌───────────────▼─────────────────────────┐
│     Integration Layer                   │
│  (Upload Collector, FileManager)       │
└───────────────┬─────────────────────────┘
                │
┌───────────────▼─────────────────────────┐
│     Master-Slave Core Layer            │
│  ┌──────────────┐  ┌──────────────┐   │
│  │ Master       │  │ Slave        │   │
│  │ - Server     │  │ - Client     │   │
│  │ - Client     │  │ - Server     │   │
│  │ - Registry   │  │              │   │
│  └──────────────┘  └──────────────┘   │
└───────────────┬─────────────────────────┘
                │
┌───────────────▼─────────────────────────┐
│     Transport Layer                     │
│  (HTTP API, JSON Protocol)              │
└─────────────────────────────────────────┘
```

### 4.2 模块职责边界

#### Master 模块（internal/master/）
- **独立模块**：不依赖其他业务模块
- **职责单一**：只负责 master-slave 通信和文件管理
- **可测试性**：所有组件都可以独立测试

#### Slave 模块（internal/slave/）
- **独立模块**：不依赖其他业务模块
- **职责单一**：只负责与 master 通信和文件服务
- **可测试性**：可以独立运行和测试

#### 集成点（internal/daemon/, internal/collector/, internal/mod/）
- **可选集成**：通过配置开关控制是否启用
- **零侵入**：通过 FileManager 接口抽象，不改变现有逻辑
- **优雅降级**：未启用时自动使用单机模式

### 4.3 依赖关系

```
Application Layer
    ↓ (depends on)
Integration Layer (FileManager)
    ↓ (depends on)
Master-Slave Core Layer
    ↓ (uses)
Transport Layer (HTTP)
```

**关键原则**：
- **单向依赖**：上层依赖下层，下层不依赖上层
- **接口抽象**：通过接口隔离，降低耦合
- **配置驱动**：通过配置控制功能启用，而非编译时依赖

## 5. 通信机制

### 5.1 通信协议

#### 协议选择：HTTP + JSON

**选择理由**：
- **简单可靠**：HTTP 协议成熟稳定，易于调试
- **无状态**：请求独立，易于扩展
- **标准协议**：工具支持丰富，便于监控和调试
- **防火墙友好**：标准端口，易于配置

#### 通信格式：JSON

**选择理由**：
- **人类可读**：便于调试和日志分析
- **跨语言**：标准格式，易于扩展
- **性能足够**：对于控制消息，JSON 性能足够

### 5.2 Master → Slave 通信

#### 5.2.1 文件扫描请求

**接口**：`POST /api/v1/files/scan`

**请求体**：
```json
{
  "task_id": "task-001",
  "start_time": "2025-01-01T00:00:00Z",
  "end_time": "2025-01-01T23:59:59Z",
  "scan_folders": ["/var/log", "/tmp"],
  "additional_files": ["/etc/config.yaml"]
}
```

**响应体**：
```json
{
  "task_id": "task-001",
  "success": true,
  "files": [
    {
      "path": "/var/log/system.log",
      "size": 1024,
      "mod_time": "2025-01-01T12:00:00Z"
    }
  ]
}
```

**关键特性**：
- **超时控制**：请求超时时间 5 秒
- **错误处理**：请求失败不影响其他 slave
- **并发执行**：所有 slave 请求并发执行

#### 5.2.2 文件下载请求

**接口**：`POST /api/v1/files/download`

**请求体**：
```json
{
  "file_path": "/var/log/system.log",
  "max_size": 10485760
}
```

**响应**：
- Content-Type: `application/octet-stream`
- 流式传输文件内容

**关键特性**：
- **流式传输**：大文件流式传输，避免内存占用
- **大小限制**：支持限制下载大小（用于追加文件）
- **超时控制**：下载超时时间 30 分钟

### 5.3 Slave → Master 通信

#### 5.3.1 注册请求

**接口**：`POST /api/v1/slave/register`

**请求体**：
```json
{
  "slave_id": "f47ac10b58cc4372",
  "ip": "192.168.1.100",
  "port": 22525,
  "version": "1.0.0",
  "file_prefix": "device1"
}
```

**响应体**：
```json
{
  "success": true,
  "message": "Slave registered successfully",
  "master_id": "master-001"
}
```

**关键特性**：
- **自动重试**：注册失败后 5 秒重试
- **IP 检测**：如果 IP 为空，从请求头自动获取
- **数量限制**：可配置最大 slave 数量

#### 5.3.2 心跳请求

**接口**：`POST /api/v1/slave/heartbeat`

**请求体**：
```json
{
  "slave_id": "f47ac10b58cc4372"
}
```

**响应体**：
```json
{
  "success": true
}
```

**关键特性**：
- **定期发送**：默认每 3 秒发送一次
- **快速失败**：心跳失败后快速重试
- **状态更新**：master 更新 slave 的最后心跳时间

#### 5.3.3 注销请求

**接口**：`POST /api/v1/slave/unregister?slave_id=xxx`

**关键特性**：
- **优雅退出**：slave 退出时主动注销
- **自动清理**：master 定期清理超时 slave

### 5.4 通信流程

#### 5.4.1 初始化流程

```
Slave 启动
    ↓
向 Master 注册
    ↓
注册成功？
    ├─ 是 → 启动心跳 goroutine
    └─ 否 → 等待 5 秒 → 重试注册
```

#### 5.4.2 心跳保活流程

```
心跳 goroutine
    ↓
每 3 秒发送心跳
    ↓
心跳成功？
    ├─ 是 → 继续心跳
    └─ 否 → 记录错误 → 继续心跳
```

#### 5.4.3 文件扫描流程

```
Master 接收任务
    ↓
并发请求所有 Slave
    ├─ Slave 1 → 扫描文件 → 返回结果
    ├─ Slave 2 → 扫描文件 → 返回结果
    └─ Slave N → 扫描文件 → 返回结果
    ↓
聚合所有结果
    ↓
创建上传任务
```

#### 5.4.4 文件上传流程

```
Master 上传队列
    ↓
获取文件
    ↓
判断文件类型
    ├─ 本地文件 → 直接上传
    └─ Slave 文件 → 下载到缓存 → 上传 → 清理缓存
```

### 5.5 错误处理和容错

#### 5.5.1 通信错误处理

**Slave 注册失败**：
- 自动重试，间隔 5 秒
- 记录错误日志
- 不影响 slave 继续运行

**心跳失败**：
- 记录错误日志
- 继续发送心跳
- Master 端检测超时后标记为离线

**文件扫描失败**：
- 记录错误日志
- 跳过该 slave
- 继续处理其他 slave

**文件下载失败**：
- 记录错误日志
- 跳过该文件
- 继续上传其他文件

#### 5.5.2 容错策略

**单个 Slave 故障**：
- 不影响其他 slave 和 master
- Master 自动清理超时 slave
- 任务继续执行，只处理在线 slave

**网络抖动**：
- 请求超时后快速失败
- 心跳失败后继续重试
- Master 定期清理超时 slave

**Master 重启**：
- Slave 检测到连接失败后重试注册
- 所有 slave 重新注册
- 不影响后续任务执行

## 6. 性能和安全考虑

### 6.1 性能优化

#### 6.1.1 并发优化
- **并发扫描**：所有 slave 文件扫描请求并发执行
- **并发下载**：多个 slave 文件可以并发下载
- **流式传输**：大文件流式传输，避免内存占用

#### 6.1.2 缓存优化
- **智能缓存**：检查缓存文件大小，避免重复下载
- **自动清理**：上传完成后自动清理缓存
- **按需下载**：只在需要上传时才下载文件

#### 6.1.3 超时控制
- **快速失败**：请求超时时间 5 秒，快速失败避免阻塞
- **下载超时**：文件下载超时时间 30 分钟，适合大文件
- **心跳间隔**：3 秒心跳间隔，快速检测网络异常

### 6.2 安全考虑

#### 6.2.1 路径安全
- **路径检查**：Slave 端检查文件路径权限
- **符号链接**：解析符号链接，防止路径遍历
- **权限验证**：确保文件可读权限

#### 6.2.2 网络安全（未来增强）
- **认证机制**：建议添加 master-slave 认证
- **HTTPS 加密**：生产环境建议使用 HTTPS
- **IP 白名单**：限制可连接的 IP 地址

#### 6.2.3 资源限制
- **文件大小限制**：默认最大 100GB
- **Slave 数量限制**：可配置最大 slave 数量
- **超时控制**：防止资源耗尽

## 7. 配置和部署

### 7.1 配置项

#### Master 配置
```yaml
master_slave:
  enabled: true  # 是否启用 master 模式
  port: 22525    # Master 监听端口
  slave_timeout: 5s  # Slave 超时时间
  max_slaves: 0  # 最大 slave 数量（0=无限制）
  request_timeout: 15s  # 请求超时时间
```

#### Slave 配置
```bash
--master-addr=192.168.1.100:22525  # Master 地址
--port=22525  # Slave 监听端口
--file-prefix="device1"  # 文件前缀
```

### 7.2 部署要求

#### 人形机器人场景部署

**Master 节点（主控板）**：
- 部署在主控板上，作为整个机器人系统的数据采集中心
- 需要具备外网连接能力（通过WiFi、4G/5G模块等）
- 需要额外内存用于缓存功能板子的文件（建议至少 2GB 可用内存）
- 开放端口 22525（或自定义端口）用于接收 Slave 注册和心跳

**Slave 节点（功能板子）**：
- 部署在各个功能板子上（传感器板、执行器板、通信板等）
- 仅需内网连接（通过机器人内部网络与主控板通信）
- 内存和 CPU 占用较小（主要提供文件扫描和下载服务）
- 每个板子独立运行，互不影响

#### 网络要求
- **机器人内部网络**：所有板子在同一内网（通常为以太网或CAN总线转以太网）
- **外网连接**：主控板（Master）具备外网连接（访问云端）
- **端口开放**：Master 和 Slave 都需要开放端口 22525（或自定义端口）

#### 资源要求
- **Master（主控板）**：需要额外内存用于缓存 slave 文件（按板子数量和文件大小配置，建议至少 2GB）
- **Slave（功能板子）**：内存和 CPU 占用较小，主要提供文件服务（建议至少 512MB 可用内存）

### 7.3 监控和调试

#### 日志监控
- Master 日志：监控 slave 注册、心跳、文件请求
- Slave 日志：监控注册、心跳、文件服务

#### 健康检查
- Master：`GET /api/v1/health`
- Slave：`GET /api/v1/health`
- Slave 列表：`GET /api/v1/slaves`

## 8. 扩展性设计

### 8.1 水平扩展

**当前限制**：
- 单个 master 建议不超过 50 个 slave
- 受限于 master 的并发处理能力

**扩展方案**：
- **多 Master 架构**：多个 master 节点，每个管理部分 slave
- **Master 集群**：Master 节点集群化，共享 slave 注册表

### 8.2 功能扩展

**可能的增强**：
- **断点续传**：大文件支持断点续传
- **压缩传输**：文件传输时压缩，减少带宽
- **增量同步**：只传输变化的文件
- **任务分发**：Master 向 Slave 分发任务，而非仅文件扫描

### 8.3 协议扩展

**当前协议**：
- HTTP + JSON，简单可靠

**未来可能**：
- gRPC：更高性能的二进制协议
- WebSocket：长连接，减少握手开销
- 消息队列：异步任务处理

## 9. 总结

### 9.1 解决的核心问题

Master-Slave 架构完美解决了**人形机器人多板子控制场景下的文件采集问题**：

- **问题**：单个机器人由多个独立的控制板子组成，每个板子产生各自的日志和数据文件，当前单机模式无法统一采集所有板子的文件
- **方案**：主控板作为 Master，各个功能板子作为 Slave，Master 统一接收云端任务，并发采集所有板子的文件，实现完整的机器人数据采集
- **价值**：无需在每个板子上配置云服务连接，只需主控板具备外网连接，即可实现整个机器人系统的统一数据采集

### 9.2 核心设计原则

1. **零破坏性**：现有单机模式完全兼容，通过配置开关控制，不影响现有部署
2. **统一抽象**：文件路径统一标识（`slave://slaveID/absolutePath`），文件管理器统一接口，消除特殊情况
3. **简单可靠**：HTTP API 通信，无复杂依赖，适合机器人内部网络环境
4. **容错性强**：单个板子（slave）故障不影响其他板子和整体功能，机器人可继续运行
5. **优雅降级**：未启用 master-slave 时自动使用单机模式，向后兼容

### 9.3 设计哲学

整个设计遵循"好品味"原则：
- **消除特殊情况**：通过统一的文件路径标识和文件管理器接口，本地文件和 slave 文件使用相同的处理流程
- **统一数据流**：Task、Rule、Upload 模块统一增强，而非特殊处理，保持代码简洁
- **简洁可靠**：HTTP API 通信，无复杂依赖，适合机器人内部网络环境，易于调试和维护

通过清晰的模块划分和接口抽象，实现了 master-slave 功能的零侵入集成，同时保持了系统的可维护性和可扩展性。无论是人形机器人的多板子控制场景，还是通用的分布式环境，都能完美适配。

